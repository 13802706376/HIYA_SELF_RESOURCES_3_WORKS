


一、概述
1  Hibernate是一个开放源代码的对象关系映射(ORM)框架，它对JDBC进行了非常轻量级的对象封装，使得Java开发人员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。

2 引入的jar包
hibernate3.jar  核心包，不说什么了
antlr.jar   一个语言转换工具，Hibernate利用它实现 HQL 到 SQL 的转换
cglib.jar  CGLIB库，Hibernate用它来实现PO字节码的动态生成，非常核心的库，必须使用的jar包 
asm.jar   一个字节码文件加强工具，用IDE工具同时添加Spring跟hibernate支持的时候，会出现asm包的冲突，删去一份，或直接全删了，自己去下来总包放上就好了
commons-collections.jar    collections Apache 的工具集,用来增强Java对集合的处理能力
commons-logging.jar      Apache Commons包中的一个，包含了日志功能，必须使用的jar包
jta.jar      标准的 JAVA 事务处理接口
dom4j.jar   dom4j XML 解析器，解析Hibernate的配置文件



三、基本代码

1  在hibernate.cfg.xml中配置
<hibernate-configuration>
	<session-factory>
		<property name="connection.username">czj_001</property>
		<property name="connection.url">jdbc:oracle:thin:@127.0.0.1:1521:wade</property>
		<property name="dialect">org.hibernate.dialect.Oracle9Dialect</property>
		<property name="myeclipse.connection.profile">czj_001</property>
		<property name="connection.password">wade399</property>
		<property name="connection.driver_class"> oracle.jdbc.driver.OracleDriver</property>
		<mapping resource="bo/Book.hbm.xml" />
		<mapping resource="bo/City.hbm.xml" />
	</session-factory>
</hibernate-configuration>

2  VO映射
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- 
    Mapping file autogenerated by MyEclipse Persistence Tools
-->
<hibernate-mapping>
    <class name="com.bgf.web.persistance.employee.bo.SalaryStepBo" table="T_SALARY_STEP" schema="BGF_VR001">
        <id name="salId" type="java.lang.String">
            <column name="SAL_ID" length="200" />
            <generator class="assigned" />
        </id>
        <property name="salStep" type="java.lang.String">
            <column name="SAL_STEP" length="200" />
        </property>
        <property name="salTecStep" type="java.lang.String">
            <column name="SAL_TEC_STEP" length="200" />
        </property>
        <property name="salRemark" type="java.lang.String">
            <column name="SAL_REMARK" length="1000" />
        </property>
        <set name="empRecordBosForRecUppBefSalstep" inverse="true">
            <key>
                <column name="REC_UPP_BEF_SALSTEP" length="200" />
            </key>
            <one-to-many class="com.bgf.web.persistance.employee.bo.EmpRecordBo" />
        </set>
        <many-to-one name="employeeBoByOaRestConnecter" class="com.bgf.web.persistance.employee.bo.EmployeeBo" fetch="select">
            <column name="OA_REST_CONNECTER" length="200" />
        </many-to-one>
    </class>
</hibernate-mapping>


3  java类的增删改查
     
              //全部查询返回list
             try{
              SessionFactory sf = new Configuration().configure().buildSessionFactory();
	      Session session = sf.openSession();
	      Transaction tx = session.beginTransaction();
	      List<Book> list = session.createSQLQuery("select * from Book").addEntity(Book.class).list();
	      tx.commit();
	      session.close();
              }
		catch(Exception e)
		{
                    tx.rollback();throw e;
		}
		finally{
			if(session != null)session.close();			}

               //删除一个对象
                SessionFactory sf = new Configuration().configure()
				.buildSessionFactory();
		Session session = sf.openSession();
		Transaction tx = session.beginTransaction();
		session.delete(book);
		tx.commit();
		session.close();


                //根据ID删除记录
                SessionFactory sf = new Configuration().configure()
				.buildSessionFactory();
		Session session = sf.openSession();
		Transaction tx = session.beginTransaction();
		String hql = "delete from Book where id='" + id + "'";
		session.createQuery(hql).executeUpdate();
		tx.commit();
		session.close();

		//保存信息
		SessionFactory sf = new Configuration().configure()
				.buildSessionFactory();
		Session session = sf.openSession();
		Transaction tx = session.beginTransaction();
		session.save(book);
		tx.commit();
		session.close();

		//根据ID找到对象
		String hql = "from Book where id='" + id + "'";
		Query query = session.createQuery(hql);
		Book book = (Book) query.uniqueResult();

  4  Session的几个主要方法
	(1).save,persist保存数据，persist在事务外不会产生insert语句。
	(2).delete,删除对象
	(3).update,更新对象，如果数据库中没有记录，会出现异常。
	(4).get,根据ID查，会立刻访问数据库。
	(5).Load，根据ID查，(返回的是代理，不会立即访问数据库)。
	(6).saveOrUpdate,merge(根据ID和version的值来确定是save或update),调用merge你的对象还是托管的。
	(7).lock(把对象变成持久对象，但不会同步对象的状态)。

5  对象的状态
@ 瞬时(transient)：数据库中没有数据与之对应，超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。
@ 持久(persistent)：数据库中有数据与之对应，当前与session有关联，并且相关联的session没有关闭，事务没有提交；
  持久对象状态发生改变，在事务提交时会影响到数据库(hibernate能检测到)。
@ 脱管(detached)：数据库中有数据与之对应，但当前没有session与之关联；托管对象状态发生改变，hibernate不能检测到。



五、数据检索
数据查询与检索是Hibernate中的一个亮点。相对其他ORM实现而言，Hibernate
提供了灵活多样的查询机制。其中包括：

1. Criteria Query
Criteria Query通过面向对象化的设计，将数据查询条件封装为一个对象。简单来讲，Criteria Query可以看作是传统SQL的对象化表示，如：
Criteria criteria = session.createCriteria(TUser.class);
criteria.add(Expression.eq("name","Erica"));
criteria.add(Expression.eq("sex",new Integer(1)));
这里的criteria 实例实际上是SQL “Select * from t_user where name=’Erica’ and sex=1”的封装（我们可以打开Hibernate 的show_sql 选项，
以观察Hibernate在运行期生成的SQL语句）。

2. Hibernate Query Language (HQL)
相对Criteria，HQL提供了更接近传统SQL语句的查询语法，也提供了更全面的特性
String hql = "from org.hibernate.sample.TUser as user where user.name='Erica'";
Query query = session.createQuery(hql);
List userList = query.list();
其中我们新引入了两个子句“as”和“where”，as子句为类名创建了一个别名，而where子句指定了限定条件。
HQL子句本身大小写无关，但是其中出现的类名和属性名必须注意大小写区分。


3. SQL
List<Book> list = session.createSQLQuery("select * from Book").addEntity(Book.class).list();


六、数据关联
1 多对一
多对一(Employee - Department)
映射文件<many-to-one name=”depart” column=”depart_id”/> 

2 一对多
一对多(Department-Employee)
<set name=”employees”>
	<key column=”depart_id”/>
	<one-to-many class=”Employee”/>
</set> 

3 一对一
一对一(Person - IdCard)
1)基于主键的one-to-one(person的映射文件)
<one-to-one name=”idCard” constrained=”true”/>

4 多对多
在操作和性能方面都不太理想，所以多对多的映射使用较少，实际使用中最好转换成一对多的对象模型；Hibernate会为我们创建中间关联表，转换成两个一对多。
<set name="teacher" table="teacher_student">
	<key column="teacher_id"/>
	<many-to-many class="Student" column="student_id"/>
</set> 


九、批量处理
1 在hibernate.cfg.xml中设置批量尺寸
  <property name="hibernate.jdbc.batch_size">50</property>
  关闭二级缓存
  <property name="hibernate.cache.use_second_level_cache">false</property>

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i<100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { 
        //将本批插入的对象立即写入数据库并释放内存
        session.flush();
        session.clear();
    }
}
tx.commit();
session.close();

2 绕过hibernate，直接使用JDBC进行批量插入
    Session session=SessionFactory.openSession();
    Transaction tx=session.beginTransaction();
    Connection conn=session.connection();
    PreparedStatement stmt=conn.prepareStatement("insert into orders(orderno) values (?)");
    for(int i=0;i<1000;i++)
    {
        stmt.setString(1,"a"+i);
        stmt.addBatch();
    }
    stmt.executeBatch();
    ts.commit();
    session.close();



十、SQL语句和HQL语句
sql 面向数据库表查询
hql 面向对象查询
hql ： from 后面跟的 类名＋类对象 where 后 用 对象的属性做条件
sql： from 后面跟的是表名             where 后 用表中字段做条件
查询在Hibernate中使用查询时，一般使用Hql查询语句。
HQL（Hibernate Query Language），即Hibernate的查询语言跟SQL非常相像。不过HQL与SQL的最根本的区别，就是它是面向对象的。
使用HQL时需要注意以下几点：
l         大小写敏感
因为HQL是面向对象的，而对象类的名称和属性都是大小写敏感的，所以HQL是大小写敏感的。
Eg.HQL语句：from Cat as cat where cat.id > 1;与from Cat as cat where cat.ID > 1;是不一样的，这点与SQL不同。
l        from子句
Eg. from Cat，该句返回Cat对象实例，开发人员也可以给其加上别名，eg. from Cat as cat，对于多表查询的情况，可参考如下：
from Cat as cat, Dog as dog
其它方面都与SQL类似，在此不再赘述。


十一、事务和并发管理

1 设置隔离级别
在Hibernate的配置文件中可以显示的配置数据库事务隔离级别。每一个隔离级别用一个整数表示：
8 - Serializable 串行化
4 - Repeatable Read 可重复读
2 - Read Commited 可读已提交
1 - Read Uncommited 可读未提交
在hibernate.cfg.xml中使用hibernate.connection.isolation参数配置数据库事务隔离级别。

2  悲观锁
悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 

Hibernate的加锁模式有： 
LockMode.NONE ： 无锁机制。 
LockMode.WRITE ：Hibernate在Insert和Update记录的时候会自动 
获取。 
LockMode.READ ： Hibernate在读取记录的时候会自动获取。 
以上这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update 
过程中对象不会被外界修改，会在save方法实现中自动为目标对象加上WRITE锁。 
LockMode.UPGRADE ：利用数据库的for update子句加锁。 
LockMode. UPGRADE_NOWAIT ：Oracle的特定实现，利用Oracle的for update nowait子句实现加锁。 

 Hibernate的悲观锁，也是基于数据库的锁机制实现。 下面的代码实现了对查询记录的加锁： 1  String hqlStr  =   " from TUser as user where user.name=’Erica’ " ; 
2 Query query  =  session.createQuery(hqlStr); 
3 query.setLockMode( " user " ,LockMode.UPGRADE);  // 加锁  
4  List userList  =  query.list(); // 执行查询， 
获取数据 query.setLockMode 对查询语句中特定别名所对应的记录进行加锁（我们为 TUser类指定了一个别名“user”），这里也就是对返回的所有user记录进行加锁。 观察运行期Hibernate生成的SQL语句： 


1  select tuser0_.id as id, tuser0_.name as name, tuser0_.group_id as group_id, tuser0_.user_type as user_type, tuser0_.sex as sex from t_user tuser0_ where (tuser0_.name = ’Erica’ )  for  update 
 这里Hibernate通过使用数据库的for update子句实现了悲观锁机制。 

上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： 
Criteria.setLockMode 
Query.setLockMode 
Session.lock 
注意，只有在查询开始之前（也就是Hiberate 生成SQL 之前）设定加锁，才会 真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含for update 子句的Select SQL加载进来，所谓数据库加锁也就无从谈起。 



3 乐观锁
基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 

1． 首先为TUser的class描述符添加optimistic-lock属性：  < hibernate - mapping >  
 < class  
name = " org.hibernate.sample.TUser "  
table = " t_user "  
dynamic - update = " true "  
dynamic - insert = " true "  
optimistic - lock = " version "  
 >  
…… 
 </ class >  
 </ hibernate - mapping >   
 

 添加一个Version属性描述符 
代码内容
 1  < hibernate - mapping >   
 2  < class   
 3 name = " org.hibernate.sample.TUser "   
 4 table = " t_user "   
 5 dynamic - update = " true "   
 6 dynamic - insert = " true "   
 7 optimistic - lock = " version "   
 8  >   
 9  < id  
10 name = " id "   
11 column = " id "   
12 type = " java.lang.Integer "   
13  >   
14  < generator  class = " native " >   
15  </ generator >   
16  </ id >   
17  < version  
18 column = " version "   
19 name = " version "   
20 type = " java.lang.Integer "   
21  />   
22 ……  
23  </ class >   
24  </ hibernate - mapping >   
25  

 



注意version 节点必须出现在ID 节点之后。
 这里我们声明了一个version属性，用于存放用户的版本信息，保存在TUser表的 version字段中。 此时如果我们尝试编写一段代码，更新TUser表中记录数据，如： 
代码内容

1  Criteria criteria  =  session.createCriteria(TUser. class );  
2 criteria.add(Expression.eq( " name " , " Erica " ));  
3 List userList  =  criteria.list();  
4 TUser user  = (TUser)userList.get( 0 );  
5 Transaction tx  =  session.beginTransaction();  
6 user.setUserType( 1 );  // 更新UserType字段   
7  tx.commit();  
8  

每次对TUser进行更新的时候，我们可以发现，数据库中的version都在递增。 而如果我们尝试在tx.commit 之前，启动另外一个Session，对名为Erica 的用 户进行操作，以模拟并发更新时的情形： 
代码内容

 1  Session session =  getSession();  
 2 Criteria criteria  =  session.createCriteria(TUser. class );  
 3 criteria.add(Expression.eq( " name " , " Erica " ));  
 4 Session session2  =  getSession();  
 5 Criteria criteria2  =  session2.createCriteria(TUser. class );  
 6 criteria2.add(Expression.eq( " name " , " Erica " ));  
 7 List userList  =  criteria.list();  
 8 List userList2  =  criteria2.list();TUser user  = (TUser)userList.get( 0 );  
 9 TUser user2  = (TUser)userList2.get( 0 );  
10 Transaction tx  =  session.beginTransaction();  
11 Transaction tx2  =  session2.beginTransaction();  
12 user2.setUserType( 99 );  
13 tx2.commit();  
14 user.setUserType( 1 );  
15 tx.commit();  
16  
执行以上代码，代码将在tx.commit()处抛出StaleObjectStateException异 常，并指出版本检查失败，当前事务正在试图提交一个过期数据。通过捕捉这个异常，我 们就可以在乐观锁校验失败时进行相应处理。 


4  悲观锁与乐观锁的比较
悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受; 
相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中

十二、分页实现
Query q = session.createQuery("from Cat as c");;   
q.setFirstResult(20000);;   
q.setMaxResults(100);;   
List l = q.list();;  


十三、缓存管理
1 缓存分类
Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。
Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。

2 一级缓存的管理
当应用程序调用Session的save()、update()、savaeOrUpdate()、get()或load()，以及调用查询接口的list()、iterate()或filter()方法时，如果在Session缓存中还不存在相应的对象，Hibernate就会把该对象加入到第一级缓存中。当清理缓存时，Hibernate会根据缓存中对象的状态变化来同步更新数据库。
Session为应用程序提供了两个管理缓存的方法：
evict(Object obj)：从缓存中清除参数指定的持久化对象。
clear()：清空缓存中所有持久化对象。

3 二级缓存的管理
1) 条件查询的时候，总是发出一条select * from table_name where …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。 
2) 把获得的所有数据对象根据ID放入到第二级缓存中。 
3) 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。 
4) 删除、更新、增加数据的时候，同时更新缓存。
　　Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query Cache

4 什么样的数据适合存放到第二级缓存中
1) 很少被修改的数据
2) 不是很重要的数据，允许出现偶尔并发的数据
2) 不会被并发访问的数据
4) 参考数据,指的是供应用参考的常量数据，它的实例数目有限，它的实例会被许多其他类的实例引用，实例极少或者从来不会被修改。

5 什么样的数据不适合存放到第二级缓存中
1 经常被修改的数据
2 财务数据，绝对不允许出现并发
3 与其他应用共享的数据。

6  常用的缓存插件
Hibernater 的二级缓存是一个插件，下面是几种常用的缓存插件：
l EhCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。
l OSCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。
l SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。
l JBossCache：可作为群集范围内的缓存，支持事务型并发访问策略，对Hibernate的查询缓存提供了支持。

7 配置二级缓存
1)      把ehcache-1.2.3.jar加入到当前应用的classpath中。
2)      在hibernate.cfg.xml文件中加入EhCache缓存插件的提供类。
<property name="hibernate.cache.provider_class">
    org.hibernate.cache.EhCacheProvider
</property> 
(3)  Hibernate允许在类和集合的粒度上设置第二级缓存。在映射文件中，<class>和<set>元素都有一个<cache>子元素，这个子元素用来配置二级缓存。
示例：以category(产品类别)和product(产品)的映射为例：
1)      修改要配置缓存的那个持久化类的对象关系映射文件：
Category.hbm.xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
 
<hibernate-mapping>
    <class name="org.qiujy.domain.cachedemo.Category" table="categories">
       <!―
             配置缓存,必须紧跟在class元素后面
            对缓存中的Category对象采用读写型的并发访问策略
        -->
       <cache usage="read-write"/>
       
       <id name="id" type="java.lang.Long">
           <column name="id" />
           <generator class="native" />
       </id>
       <!-- 配置版本号,必须紧跟在id元素后面 -->
       <version name="version" column="version" type="java.lang.Long" />
       
       <property name="name" type="java.lang.String">
           <column name="name" length="32" not-null="true"/>
       </property>
       
       <property name="description" type="java.lang.String">
           <column name="description" length="255"/>
       </property>
       
       <set name="products" table="products" cascade="all" inverse="true">
           <!-- Hibernate只会缓存对象的简单属性的值,
       要缓存集合属性,必须在集合元素中也加入<cache>子元素
       而Hibernate仅仅是把与当前持久对象关联的对象的OID存放到缓存中。
如果希望把整个关联的对象的所有数据都存入缓存,
则要在相应关联的对象的映射文件中配置<cache>元素
           -->
           <cache usage="read-write"/>
           
           <key column="categoryId" not-null="true"/>
           <one-to-many class="org.qiujy.domain.cachedemo.Product"/>
       </set>
       
    </class>
</hibernate-mapping>

8 查询缓存
对于经常使用的查询语句，如果启用了查询缓存，当第一次执行查询语句时，Hibernate会把查询结果存放在第二缓存中。以后再次执行该查询语句时，只需从缓存中获得查询结果，从而提高查询性能。

 缓存策略：
1) Hibernate首先根据这些信息组成一个Query Key，Query Key包括条件查询的请求一般信息：SQLSQL需要的参数，记录范围（起始位置rowStart，最大记录个数maxRows)，等。 
2) Hibernate根据这个Query Key到Query缓存中查找对应的结果列表。如果存在，那么返回这个结果列表；如果不存在，查询数据库，获取结果列表，把整个结果列表根据Query Key放入到Query缓存中。 
3) Query Key中的SQL涉及到一些表名，如果这些表的任何数据发生修改、删除、增加等操作，这些相关的Query Key都要从缓存中清空。

9 配置查询缓存
(1) 在hibernate.cfg.xml添加如下配置
<! --启用查询缓存 -->
<property name="cache.use_query_cache">true</property> 

 tx = session.beginTransaction(); 
                     Query query = session.createQuery("from Product");
                     //激活查询缓存
                     query.setCacheable(true);
                     //使用自定义的查询缓存区域,若不设置,则使用标准查询缓存区域
                     query.setCacheRegion("myCacheRegion");
                     
                     List list = query.list();
                     for(int i = 0 ; i < list.size(); i++){
                            Product prod = (Product)list.get(i);
                            System.out.println(prod.getName());
                     }
                     
                    tx.commit();



十四、提升性能
1 表结构之间的映射关系及延迟加载 
表结构的映射关系就是从er图区理解就可以，面向对象的思维去理解，是一对多或是一对一，多对多就如网上介绍的方法配置就可以了。关键一点就是一对多的时候在一的一方要设置成lazy='true',启用延迟加载。我在程序运行的时候不需要数据的时候呢，就不用查一些无关紧要的数据了。但是需要的时候我们还是可以通过fetch关键字强制查询出来的；举个例子：我的丽生网中丽生交流栏目列表数据，是topic和发布用户user多对一得关系，在我查询topic的时候需要user的数据，那我在查询的时候就可以使用fetch关键字把user的数据查出来。不然你在查询了topic后，启用了延迟加载会再次执行一条sql语句去查询user的信息，这样性能稍微下降了。

2 缓存的使用（查询缓存的使用和二级缓存）
就是使用缓存，缓存用好了给你系统带来超快的运行速度，更好的性能，但是要注意缓存参数的配置。配置方法网上就可以了，参数配置有个规则：查询缓存过期时间一定要小于类的缓存过期时间。

3 查询语句的优化


十五、懒加载

lazy属性可以配置在: 

(常用)<set><list>标签上,可以取值true,false,extra 
            默认为true,当为true时,会懒加载,访问集合属性时再发出SQL语句.但set.size()时,很不智能,不会生成count()语句,而是查出所有记录赋值给set. 
            extra说明:调用集合的set.size()时,会生成select count(*)from tableName,比较智能.建议使用 
(少用)<many-to-one><one-to-one>标签上,可以取值false,proxy,noproxy 
            当为true时,会有懒加载特性,当为false时会产生N+1问题,比如一个学生对应一个班级,用一条SQL查出10个学生,当访问学生的班级属性时Hibernate会再产生10条SQL分别查出每个学生对应的班级. 
(不用)<class>标签上,可以取值true,false 
            默认为true,当为false时,load()方法将失去懒加载的特性与get()一样,不影响集合(<set><list>)标签上的lazy特性 
(不用)<property>标签上,可以取值true,false 
            默认值为false,懒加载某个字段,无意义,不要使用 

---------------------------------------------------------- 
get()与load()的区别 
get()无懒加载特性,马上执行SQL查询. 
load()有懒加载特性,会返加一个代理对象,所以永远不为null,先不执行SQL,要取对象的值时才执行SQL语句,前题session不能关闭,<class>标签上lazy不为false. 

---------------------------------------------------------- 
实现懒加载的前提:1 PO不能是final的 
2 能实现懒加载的对象(PO)都是被CGLIB改写的代理对象,所以不能是final修饰的 
3 须要asm,cglib两个jar包 
4 相应的lazy属性为true 
5 相应的fetch属性为select 
---------------------------------------------------------- 
什么时候出遇到懒加载 
1 使用load() 
2 一对一<one-to-one> 
查主对象 默认使用join连接,不会发生懒加载 
查从对象 默认会发生懒加载,先执行一句select查出从对象,当通过从对象访问了主对象时,再执行一句select查出主对象. 

3 多对一<many-to-one> 
在使用hbm.xnl时，取多的一方时，默认会懒加载，不取一的一方 
在使用JPA时，取多的一方时，默认自动使用join on语句取出一的一方（用户与组，用户是多的一方，组是一的一方） 

4 一对多(<set><list>) 
默认会懒加载，这是必须的，是重常用的。 

---------------------------------------------------------- 
实现懒加载的方案: 


方法一:(没有使用懒加载)   
用 Hibernate.initialize(de.getEmps()) 提前加载一下. 

方法二: 
把与Session脱离的对象重新绑定 
lock()方法是用来让应用程序把一个未修改的对象重新关联到新session的方法。

Java代码   
//直接重新关联    
session.lock(fritz, LockMode.NONE);    
//进行版本检查后关联    
session.lock(izi, LockMode.READ);    
//使用SELECT ... FOR UPDATE进行版本检查后关联    
session.lock(pk, LockMode.UPGRADE);   
Java代码  
//直接重新关联   
session.lock(fritz, LockMode.NONE);   
//进行版本检查后关联   
session.lock(izi, LockMode.READ);   
//使用SELECT ... FOR UPDATE进行版本检查后关联   
session.lock(pk, LockMode.UPGRADE);  


